<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>php的闭包序列化</title><url>/post/php-closure-serialize/</url><categories><category>php</category></categories><tags><tag>php</tag><tag>closure</tag><tag>serialized</tag></tags><content type="html">PHP 闭包序列化：实现和对现有程序的思考 在 PHP 中，闭包是一种非常强大的特性，可以让我们编写更简洁、更灵活的代码。然而，当我们需要将闭包序列化并保存到文件或数据库中时，可能会遇到一些问题。本文将介绍如何实现 PHP 闭包序列化，并探讨这一过程对现有程序的影响。
什么是闭包？ 在 PHP 中，闭包是一种可以访问其定义范围内变量的函数。换句话说，它们可以捕获其创建时所处的上下文，并在稍后执行时访问该上下文。闭包通常用于创建回调函数、生成器和事件处理程序等。
以下是一个简单的闭包示例(好像又没那么简单)：
$multiplier = function ($x) { return function ($y) use ($x) { return $x * $y; }; }; $double = $multiplier(2); echo $double(5); // 输出 10 在上面的例子中，$multiplier 是一个接收一个参数 $x 的函数，它返回另一个接收一个参数 $y 的函数。返回的函数使用了 $x，这个值是从外部作用域中“捕获”的。
为什么需要序列化闭包？ 在某些情况下，我们可能需要将闭包保存到文件或数据库中，以便稍后使用。例如，现有代码，需要异步处理时，又不想改动太大，我们就需要将现有执行逻辑打包，做成闭包后序列化并保存到数据库中，以便稍后异步执行。
实现闭包序列化 PHP 提供了 serialize() 和 unserialize() 函数，可以将大部分 PHP 数据类型序列化为字符串，并在稍后还原它们。然而，serialize() 和 unserialize() 函数不能正确地序列化闭包。
要序列化闭包，我们需要首先安装 opis/closure 包,
composer require opis/closure 然后使用闭包序列化, (注意这里使用了包中的序列化函数)：
use function Opis\Closure\{serialize, unserialize}; $factorial = function ($n) use (&amp;amp;$factorial) { return $n &amp;lt;= 1 ? 1 : $factorial($n - 1) * $n; }; $serialized = serialize($wrapper); 要还原闭包，我们需要使用以下代码：
use function Opis\Closure\{serialize, unserialize}; $wrapper = unserialize($serialized); echo $wrapper(5); // 输出：120 对现有程序的影响 将闭包序列化后，它们的执行环境被固定在序列化时的状态。 换句话说，如果您序列化了一个闭包，并将其保存到文件或数据库中，然后稍后还原它并尝试执行它，它将访问当时的变量值，而不是当前的变量值。 如果一个闭包使用了资源类型（如文件句柄），那么它就不能被序列化。 如果您需要序列化这种类型的闭包，请考虑将其改为使用其他类型的变量，例如文件路径。 避免在序列化闭包时，闭包中传入了超大容量的参数(如数据库查询结果集)，这样会导致序列化后的字符串长度非常长。 如果必须这样，可以考虑传查询条件，让其再闭包中去执行相关查询操作。 结论 在 PHP 中，序列化闭包是一项非常具有挑战性的任务。然而，通过使用 opis/closure ，我们可以非常简单地实现这个目标。然后大战拳脚吧。</content></entry><entry><title>webman与docker开发环境交互</title><url>/post/webman-sail/</url><categories><category>php</category></categories><tags><tag>php</tag><tag>webman</tag><tag>docker compose</tag><tag>docker</tag></tags><content type="html"> 简介 Webman Sail 是一个轻量级的命令行界面，用于 Webman 与 Docker 开发环境进行交互。Sail 为使用 PHP，MySQL 和 Redis 构建 Webman 应用程序提供了一个很好的起点，而无需事先具有 Docker 经验。
Sail 的核心是 docker-compose.yml 文件和存储在项目根目录的 sail 脚本。sail 脚本为 CLI 提供了便捷的方法，可用于与 docker-compose.yml 文件定义的 Docker 容器进行交互。
Webman Sail 支持 macOS、Linux 和 Windows (通过 WSL2 ）。
安装 &amp;amp; 启动 安装依赖 composer require roiwk/webman-sail --dev webman命令执行 sail:install。这个命令用于发布 docker-compose.yml文件到你应用程序的根目录： php webman sail:install 或者直接指定需要安装的服务：
php webman sail:install --with=mysql,redis 启动服务。 ./vendor/bin/sail up 访问： http://localhost 即可。 至此，基本的环境安装已经就绪，下来是配置和使用相关的文档：
环境变量 php版本默认使用8.1版本。 默认版本支持 7.4-8.2,更多可查看 定制容器 ; 具体版本按需设置.env文件中的配置即可。 PHP_CLI_VERSION=8.1 数据库配置 DB_PORT=3306 DB_DATABASE=test DB_USERNAME=dev DB_PASSWORD=123456 DB_ROOT_PASSWORD=password 执行命令 help，查看支持的指令帮助。 ./vendor/bin/sail --help sail === docker-compose 相当于docker-compose指令。 ./vendor/bin/sail up -d ./vendor/bin/sail down ./vendor/bin/sail ps sail === php-cli(container) 链接容器内部php指令。 ./vendor/bin/sail php test.php ./vendor/bin/sail php -v sail === composer(container) 链接容器内部composer指令。 ./vendor/bin/sail composer update ./vendor/bin/sail composer require foo/bar ./vendor/bin/sail composer remove foo/bar sail === mysql-cli 链接mysql/mariadb/psql容器内部指令。 ./vendor/bin/sail mysql sail === redis-cli 链接redis容器内部指令。 ./vendor/bin/sail redis sail === shell(container) 链接应用容器内部shell指令。 ./vendor/bin/sail shell ./vendor/bin/sail root-shell #root用户 sail === phpunit(container) 执行应用容器内部phpunit指令。 ./vendor/bin/sail phpunit --bootstrap support/bootstrap.php &amp;hellip;等等功能，
--help期待你的发现与探索。
定制容器 因为 Sail 就是 Docker，所以你可以自由的定制任何内容，使用 sail:publish 命令可以将 Sail 预设的 Dockerfile 发布到你的应用程序中，以便于进行定制：
./vendor/bin/sail webman sail:publish 运行这个命令后，Sail 预设好的 Dockerfile 和其他配置文件将被生成发布到项目根目录的 docker 目录中。 完成上述操作后，可以按需修改Dockerfile中的php扩展等。修改完成后，执行以下命令重新构建容器即可：
./vendor/bin/sail build --no-cache 贡献 欢迎提交PR
开源许可协议 MIT LICENSE - Gitee Storage MIT LICENSE - Github Storate</content></entry><entry><title>关于我选择Manjaro作为桌面系统 第二集 NVIDIA驱动</title><url>/post/manjaro-for-me-of-two/</url><categories><category>Manjaro</category><category>NVIDIA</category></categories><tags><tag>Manjaro</tag><tag>NVIDIA</tag></tags><content type="html"><![CDATA[关于我选择Manjaro作为桌面系统 第二集 NVIDIA驱动 系统已安装，默认环境也都够用了，现在开始安装N卡驱动。
显卡放着,不能让它不干活啊，生产队的驴都不敢这么歇着。
【推荐】方法一: 从Manjaro存储库自动安装Nvidia驱动 自动检测系统，并安装适当的Nvidia驱动 sudo mhwd -a pci nonfree 0300 重启系统 sudo reboot 重启后，配置显卡 nvidia-settings 官方库有支持就是简单直接，一步到位。安装成功
方法二: 使用官网驱动安装 Nvidia官网搜索驱动下载 具体安装步骤请参考这里 1
遇到的问题与解决: 我的GTX1050Ti,推荐方法安装完成之后，默认没使用到显卡，驱动安装成功了。 解决方案： 安装optimus-manager 配置与安装借鉴： 双显卡切换情况，N卡和intel核卡2 显卡切换，整体安装与/etc/ssdm.conf配置过程，借鉴内容3 optimus-mananer --switch nvidia时，报错时，借鉴报错信息4 总结 推荐安装方式还是简单，安装之后，切换使用显卡，出现了问题，查了半天，
最终成功切换到N卡，附显卡监控图： https://linuxconfig.org/how-to-install-the-nvidia-drivers-on-manjaro-linux &#160;&#x21a9;&#xfe0e;
http://www.caotama.com/1153480.html &#160;&#x21a9;&#xfe0e;
https://archived.forum.manjaro.org/t/guide-install-and-configure-optimus-manager-for-hybrid-gpu-setups-intel-nvidia/92196 &#160;&#x21a9;&#xfe0e;
https://github.com/Askannz/optimus-manager#important--manjaro-kde-users &#160;&#x21a9;&#xfe0e;
]]></content></entry><entry><title>关于我选择Manjaro作为桌面系统 第一集</title><url>/post/manjaro-for-me-of-one/</url><categories><category>Manjaro</category><category>primer</category></categories><tags><tag>Manjaro</tag><tag>Plasma Desktop</tag></tags><content type="html"><![CDATA[关于我选择Manjaro作为桌面系统 第一集 起因 总的来说就是：还没钱买新电脑，这个还能用，想再折腾折腾
手上笔记本,C盘满了又删，删了又满，基本每过两月就得经历；
CC cleaner 安装了两年了；每次清理都有种上大学时用的手机的感觉，也是存储不够，天天满，天天清；
用了5年多的笔记本，
win10-专业版
24G(16G+8G)
128G-SSD
1T-HHD
I5-7th 4核
GTX-1050Ti(4G显存)
原配是8G，后面内存条降价时候加了个16G。（咔～，快照留念。）
已安装的开发环境max 👇： docker,wsl,rust,php,golang,node,python,vscode,navicate,mobaxterm,postman,chrome,apifox,vnode 所以，新系统必须具备我开发环境，GUI用着舒服就行。 游戏的话，以后台式机打吧，这显卡，大游戏也支撑不了了，卡而且散热是个问题。 开搞 去 Distrowatch 看了下，之前就关注过 Manjaro ,排名还是在前5的, Distrowatch-Manjaro ,果断准备用ta了。
Manjaro 吸引我的优点： 桌面系统种类丰富-gnome,plasma,xface等； 稳定性-linux内核稳定版本； 官方软件库相对完整-有软件需求的，基本官方库就有了； 目标确定，开始操作：
下载镜像 Manjaro官网下载 我选了plasma kde桌面版（喜欢kde）。 安装系统 我使用了 Ventory 系统安装步骤，刚开始配个语言，认识language单词即可，选中文，全程鼠标操作，顺利完成。 记住设置的密码和超级密码 安装软件 启动后的系统，有Manjaro Hello软件会自动启动,
按需安装软件；这里都是推荐的，兼容性相对较高的软件。 还不错 快捷键操作，基本与win差不多,常用的都还能用，不喜欢的可以配置，系统设置 里可以设置；
Win+E Alt+Tab Ctl+C Ctl+V &hellip; win平台各种软件的替代方案：
win软件 manjaro软件 vscode code-oss(vscode-linux版) chrome浏览器 chromium office onlyoffice 中文输入法 IBus 1 Manjaro Hello-&gt;Applications 这个官方推荐app里，有许多常用软件，基本可以满足日常的工作所需。
结束 至此，基本的linux桌面版系统-Manjaro环境以有了，接下来继续熟悉和持续使用中～～
捣鼓半天设置的桌面： 打开Manjaro Hello-&gt;Applications-&gt;Extended language support-&gt;Manjaro Asian Input Support Ibus 选中，然后点击右上角UPADATE SYSTEM，安装并配置即可。&#160;&#x21a9;&#xfe0e;
]]></content></entry><entry><title>Hello Blog</title><url>/post/hello-blog/</url><categories><category>note</category></categories><tags><tag>introduction</tag></tags><content type="html">Hi 你好，首次发布，记录一下。
采用 Hugo (主题: Next ) + Github Page + Github Actions 构建。
未来将分享一些文章。
加油！blog~</content></entry><entry><title>关于我</title><url>/about.html</url><categories/><tags/><content type="html"> 联系方式</content></entry><entry><title>友盟openAPI的php实现</title><url>/post/umeng-openapi/</url><categories><category>php</category></categories><tags><tag>php</tag><tag>umeng</tag><tag>composer</tag></tags><content type="html"><![CDATA[简介 一个简单,好用的友盟open-api的包&hellip; 封装了友盟官方open-api的sdk, 官方sdk版本1.1.4
umeng官方文档 安装 composer require roiwk/umeng-open-api 快速使用 例子: 获取应用的累计用户数 此示例的umeng文档 require_once &#39;path/to/autoload.php&#39;; use Roiwk\UmengOpenAPI\Factory; // 工厂类中，有具体的小程序，app等应用类型，详见源码即可 $app = Factory::umini([ &#39;api_key&#39; =&gt; &#39;your key&#39;, &#39;api_secret&#39; =&gt; &#39;your secret&#39;, &#39;app_key&#39; =&gt; &#39;your APPKEY&#39;, // 指定 API 调用返回结果的类型：json(default)/array/object/raw(resultObject) &#39;response_type&#39; =&gt; &#39;json&#39;, ]); // 参数1:api名 (com.umeng.umini:umeng.umini.getTotalUser-1, 传&#34;getTotalUser&#34; 即可) // 参数2: 请求参数数组 $app-&gt;get(&#39;getTotalUser&#39;, [ &#39;fromDate&#39; =&gt; &#39;2020-11-01&#39;, &#39;toDate&#39; =&gt; &#39;2020-11-01&#39;, &#39;pageIndex&#39; =&gt; 1, &#39;pageSize&#39; =&gt; 10, ]); 项目缘由 友盟官方的sdk, 在已有的composer项目中,用起来很不方便, 所以封装一个用.
贡献 欢迎提交PR
开源许可协议 - MIT MIT LICENSE - Gitee Storage MIT LICENSE - Github Storate ]]></content></entry><entry><title>Docker 入门</title><url>/post/docker-introduction/</url><categories><category>docker</category><category>primer</category></categories><tags><tag>docker</tag><tag>primer</tag></tags><content type="html"><![CDATA[Docker 入门 Docker 一. 是什么 1.Docker概念与简要历史 Docker 是一个开源的应用容器引擎，你可以将其理解为一个轻量级的虚拟机， 开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上。
Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新， 并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。
Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 4 万 6 千个星标和一万多个 fork。 甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为Docker。 Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。
Docker 使用 Google 公司推出的 Go 语言 进行开发实现， 基于 Linux 内核的cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。 由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。 最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。
Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。 使得 Docker 技术比虚拟机技术更为轻便、快捷。
2.与传统虚拟方式的不同 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程； 而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。
二. 为什么 1.使用Docker的原因 作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。
1&gt; 更高效的利用系统资源
由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。 无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。 因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。
2&gt; 更快速的启动时间
传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。 大大的节约了开发、测试、部署的时间。
3&gt; 一致的运行环境
开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。 而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。
4&gt; 持续交付和部署
对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。 使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。 开发人员可以通过 Dockerfile 来进行镜像构建，并结合持续集成(Continuous Integration) 系统进行集成测试， 而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。 而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。
5&gt; 更轻松的迁移
由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。 Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。 因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。
6&gt; 更轻松的维护和扩展
Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。 此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。
7&gt; 对比传统虚拟机总结
特性 容器 虚拟机 启动 秒级 分钟级 硬件使用 一般为MB 一般为GB 性能 接近原生 弱于 系统支持量 单机支持上千个容器 一般几十个 2.用途 1&gt; 提供一次性的环境。
比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。
2&gt; 提供弹性的云服务。
因为 Docker 容器可以随开随关，很适合动态扩容和缩容。
3&gt; 组建微服务架构。
通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。
三. 怎么做 1.基本概念 1&gt; 镜像
镜像就是一个只读的模板。 例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。
镜像可以用来创建 Docker 容器。 Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。
2&gt; 容器
Docker 利用容器来运行应用。 容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。 可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。
3&gt; 仓库
仓库是集中存放镜像文件的场所。 有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。
仓库分为公开仓库（Public）和私有仓库（Private）两种形式。 最大的公开仓库是 Docker Hub ，存放了数量庞大的镜像供用户下载。 2.快速入门 安装下载 win10/mac 下载 win10以下版本下载 docker-tool 实战nginx容器搭建 要求：配置和站点文件不放进容器（方便管理） 官方仓库 sart=&gt;start: 开始:&gt;https://hub.docker.com/_/nginx/[blank] end=&gt;end: 结束:&gt;https://hub.docker.com/_/nginx/[blank] io_input=&gt;inputoutput: 搭建后销毁nginx op_pull=&gt;operation: 拉取镜像(docker pull) op_run=&gt;operation: 运行容器(docker run) op_stop=&gt;operation: 停止容器(docker stop) op_destory=&gt;operation: 销毁容器(docker rm) op_rm=&gt;operation: 删除镜像(docker rmi) io_service=&gt;inputoutput: 完成-搭建后销毁 sub_params=&gt;subroutine: 进入容器(docker exec) op_stop=&gt;operation: 容器关闭状态 cond_stop=&gt;condition: 是否关闭容器? sub_stop=&gt;subroutine: 关闭容器(docker stop) sart-&gt;io_input-&gt;op_pull-&gt;op_run-&gt;sub_params-&gt;op_destory-&gt;op_rm-&gt;io_service cond_stop(yes)-&gt;sub_stop-&gt;op_stop cond_stop(no)-&gt;io_service-&gt;end 创建需要挂载的文件夹目录结构 文件、目录名 说明 -docker 将挂载到容器中 &mdash;nginx nginx容器相关文件目录 &mdash;&ndash;conf 配置目录 &mdash;&mdash;-nginx.conf 配置文件 &mdash;&ndash;www nginx站点目录 &mdash;&mdash;-index.html 主页文件 拉取镜像 docker pull nginx:1.15.7 运行容器 docker run --name nginx1 -v /c/User/share/docker/nginx/www:/usr/share/nginx/html:rw -v /c/User/share/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro -p 8000:80 -d nginx:1.15.7 注：挂载目录尽量使用绝对路径
进入容器 docker exec -it nginx1 bash 停止容器 docker stop nginx1 销毁容器 docker rm nginx1 销毁镜像 docker rmi nginx:1.15.7 3.深入与提高 1&gt; Dockerfile文件 Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。
2&gt; yml文件 下面三剑客中docker-compose的编排文件。用于快速配置和管理一组服务容器（项目）。
3&gt; Docker三剑客 Docker Compose 负责快速的部署分布式应用。 Compose 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」
Docker Machine Docker Machine 是 Docker 官方编排（Orchestration）项目 负责在多种平台上快速安装 Docker 环境。
Docker Swarm 提供 Docker 容器集群服务，是 Docker 官方对容器云生态进行支持的核心方案。
]]></content></entry></search>